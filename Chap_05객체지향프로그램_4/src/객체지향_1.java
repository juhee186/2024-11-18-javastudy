/*
 * 	114페이지
 * 	객체구성
 * 		= 속성(변수) / 동작(메소드)
 * 		= 여러개의 독립적인 단위 => 부품 => 조립		
 * 									--- 프로그래밍
 * 							 ----프로그램
 * 		객체를 만들 때 사용하는 키워드(설계)
 * 		---------------------클래스
 * 		메모리에 저장후 사용
 * 		--------------- 인스턴스
 * 	118페이지
 * 		= 객체에 대한 설계
 * 		= 클래스의 구성요소
 * 		class classname
 * 		{
 * 		----------------------
 * 		멤버변수
 * 		 = 인스턴스 변수 : 객체 생성시마다 메모리가 다른 공간에 저장
 * 	     = 정적변수 : 메모리 공간 1개만 생성 => 공유
 * 		  구분 : static이냐 아니냐
 * 			   -------공통으로 사용 메소드, 싱글턴: 한개의 객체 생성
 * 									  ----데이터베이스 연동
 * 									  ----스프링은 모든 클래스가 싱글턴
 * 		  => 적용(객체지향=>권장): 데이터 목적(캡슐화)
 * 			 데이터를 은닉화 => 메소드를 이용해서 접근하는 방식
 * 			 변수의 역할
 * 			  = 읽기 (메모리에서 갖고오기)
 * 				getXxx()
 * 			  = 쓰기 (메모리 저장)
 * 				setXxx()
 * 			  = 자동생성 => lombok
 * 			 변수의 사용범위 : 프로그램 종료시까지 유지
 * 							=> Heap공간에 저장
 * 							=> 다른 클래스에서도 사용가능
 * 		----------------------
 * 		생성자 : 변수에 대한 초기화, 시작과 동시에 처리기능
 * 			  => 생략가능
 * 				 -----> 컴파일러에 의해 자동생성
 * 						-----------------매개변수가 없는 생성자(디폴트 생성자)
 * 			  => 특징
 * 				1) 클래스명과 동일
 * 				2) 리턴형이 존재하지 않는다
 * 					**void : 리턴형 => 결과값 없는 경우
 * 				3) 여러개의 생성자를 만들 수 있다
 * 				   -----------같은 이름으로 생성 : 오버로딩=중복 메소드 생성
 * 				***오버로딩의 조건
 * 				1) 한 개의 클래스 안에서 만든다
 * 				2) 메소드명이 동일하다
 * 				3) 매개변수가 달라야한다(갯수, 데이터형등)
 * 				4) 리턴형은 관계가 없다
 * 			*** 초기화시 주로 생성자 이용
 * 						  ----
 * 							인스턴스변수,static변수 사용 가능
 * 			*** static 변수에 대한 초기화는 static{} 이용
 * 				=> 초기화블럭 : static변수만 초기화 가능
 * 		----------------------
 * 		메소드 : 기능설계
 * 			   ------설정된 변수를 어떻게 사용할것이냐
 * 			   ------동작
 * 			   ------자바의 단점 :callback을 만들 수 없다	
 * 							   -------
 * 								시스템에 의해 자동 호출
 * 									=> 사용자 정의 메소드는 반드시 호출
 * 									=> 스프링에서는 AOP
 * 		== 구성요소
 * 			리턴형 : 사용자 요청에 따른 결과값
 * 				=> 1개만 사용 가능
 * 				=> 기본형 / 배열 / 클래스
 * 						  |정렬	 |상세보기	
 * 			메소드명 : 구분자(메소드명이 메모리 주소)
 * 				=> 변수 식별자와 동일 / 소문자로 시작
 * 			매개변수 : 사용자 요청 값 => 여러개 사용 가능
 * 				=> 매개변수 3개 이상이면 배열,클래스 이용
 * 				=> 갯수를 모르는 경우(가변 매개변수)
 * 			[접근지정] [제어어] 리턴형 메소드 (매개변수) => 선언부
 * 			{
 * 				=> 구현부
 * 			}
 * 		----------------------
 * 		}
 * 		=> 객체지향프로그램
 * 			장점
 * 			 코드 재사용 : 상속/포함
 * 			 유지보수시 사용 용이
 * 			 대형프로그램에서 주로 사용 : 금융권/증권/공기업
 * 			  => 클래스 단위 모듈화 > 업무 분담 용이
 * 			단점
 * 			 처리속도가 느리다 > 독립적으로 사용
 * 							----------상속 거의 없다	
 * 			 결합성이 높다 > 클래스 수정시 다른 클래스에 영향
 * 			-----------스프링
 * 			 객체가 많으면 용량이 커질 수 있다(메모리 부하)
 * 			 설계시 많은 시간이 필요하다
 * 		-----------------------------------------
 * 		this / this() 
 * 		this => 클래스 자신의 메모리 주소를 설정
 * 		---- 멤버변수와 지역변수가 같은 경우 구분하기 위해
 * 		---- JVM => 객체 생성될 때 자동으로 주소값을 저장
 * 		---- 모든 멤버관련 => 메소드,변수 앞에 반드시 this. 입력
 * 			 최근 this. 생략 => 컴파일러에 의해 자동설정
 * 
 * 			컴파일러가 자동 처리
 * 			=> import java.lang.*;
 * 			=> 모든 클래스는 Object 상속
 * 			=> 메소드 안에서 void => return 추가
 * 			=> 생성자를 사용하지 않으면 디폴트 생성자 추가
 * 			=> this. 생략시 자동추가
 * 
 * 		this() => 자신 클래스의 생성자 호출시 사용
 * 		----- 사용빈도는 거의 없다
 * 		= 사용위치 => 생성자 안에서 다른 생성자 호출
 * 				    생성자의 첫줄에 코딩
 * 
 * 	122페이지 : 객체생성과 사용
 * 		=> 객체의 생명주기(생성~소멸)
 * 					  -------처리(스프링=> 클래스 관리자)
 * 		=> new를 이용하면 결합성 높은 프로그램
 * 		  ----- 객체 생성 방법이 있다
 * 		설계(class 작성) =====> 메모리 저장 =====> 활용 ======> 메모리 회수
 * 			class classname	   =>new생성자()	메소드()변수명		null=>system.gc()
 * 			{
 * 				변수/메소드/생성자
 * 			}
 * 			*** 변수만 가지고 있는 경우 / 메소드만 가지고 있는 경우 / 변수+메소드
 * 				-------데이터형클래스						--------
 * 				(사용자 정의 데이터형)						관련된 내용을 모아서 관리(잘 묶는가)
 * 			:관련된 데이터를 모아서 한번에 관리					데이터관리 :변수,배열,클래스,파일
 * 
 * 		=> 1) 메소드   2) 접근지정어  3) 상속   4) 포함   
 * 		   5) 클래스의 종류 (추상클래스, 인터페이스)
 * 		=> 예외처리 => 라이브러리(collection, IO, SQL, NetWork)
 * 		=> 프로젝트 / 오라클
 * 		=> 브라우저 (HTML/CSS/Javascript)
 */
class A
{
	void disp(int a) {
	System.out.println("disp() call"+a);
	}
}
public class 객체지향_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		A aa=new A(); // 선언과 동시 저장 123page
		aa.disp(100);
		
		A bb=new A();
		bb.disp(1000);
		
		
	}

}
